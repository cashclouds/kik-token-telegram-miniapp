require('dotenv').config();
const { Telegraf, Markup } = require('telegraf');
const express = require('express');
const logger = require('./utils/logger');
const db = require('./database/db');
const redis = require('./utils/redis');
const adManager = require('./services/adManager');
const rewardService = require('./services/rewardService');
const nftService = require('./services/nftService');
const referralService = require('./services/referralService');

// Initialize Telegram bot
const bot = new Telegraf(process.env.BOT_TOKEN);

// Express server for webhooks and health checks
const app = express();
app.use(express.json());

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// ============================================
// MIDDLEWARE
// ============================================

// Rate limiting middleware
bot.use(async (ctx, next) => {
  const userId = ctx.from?.id;
  if (!userId) return next();

  const key = `rate_limit:${userId}`;
  const requests = await redis.incr(key);

  if (requests === 1) {
    await redis.expire(key, 60); // 1 minute window
  }

  if (requests > 30) {
    return ctx.reply('‚è≥ Too many requests. Please wait a minute.');
  }

  return next();
});

// User session middleware
bot.use(async (ctx, next) => {
  if (ctx.from) {
    ctx.user = await db.getOrCreateUser(ctx.from);
    logger.info(`User ${ctx.from.id} (@${ctx.from.username}) accessed bot`);
  }
  return next();
});

// ============================================
// BOOT AD HANDLER
// ============================================

// Show boot ad when user opens bot
bot.use(async (ctx, next) => {
  // Skip for non-message updates
  if (!ctx.message && !ctx.callbackQuery) return next();

  // Skip if user has premium
  if (ctx.user?.isPremium) return next();

  // Check if user should see boot ad (once per session)
  const sessionKey = `boot_ad_shown:${ctx.from.id}`;
  const adShown = await redis.get(sessionKey);

  if (!adShown && process.env.BOOT_AD_ENABLED === 'true') {
    try {
      // Show boot ad
      const adData = await adManager.getBootAd();

      if (adData) {
        await ctx.replyWithPhoto(adData.imageUrl, {
          caption: `${adData.title}\n\n${adData.description}\n\n‚è±Ô∏è Ad will close in ${process.env.BOOT_AD_DURATION} seconds...`,
          reply_markup: {
            inline_keyboard: [
              [{ text: 'üîó Learn More', url: adData.clickUrl }],
              [{ text: '‚úñÔ∏è Close', callback_data: 'close_ad' }]
            ]
          }
        });

        // Track impression
        await adManager.trackImpression(adData.id, ctx.from.id);

        // Mark ad as shown for this session (expires in 1 hour)
        await redis.setex(sessionKey, 3600, '1');

        // Auto-close ad after duration
        setTimeout(async () => {
          try {
            await ctx.deleteMessage();
          } catch (err) {
            logger.warn('Could not delete boot ad:', err.message);
          }
        }, parseInt(process.env.BOOT_AD_DURATION) * 1000);
      }
    } catch (error) {
      logger.error('Boot ad error:', error);
      // Continue even if ad fails
    }
  }

  return next();
});

// ============================================
// COMMANDS
// ============================================

// /start - Register user and show welcome
bot.command('start', async (ctx) => {
  const args = ctx.message.text.split(' ');
  const referralCode = args[1]; // Extract referral code from /start <code>

  try {
    // Check if new user
    const isNewUser = !ctx.user.walletAddress;

    if (isNewUser) {
      // Register referral if code provided
      if (referralCode) {
        const referrer = await db.getUserByReferralCode(referralCode);
        if (referrer && referrer.id !== ctx.user.id) {
          await referralService.registerReferral(ctx.user.id, referrer.id);
          logger.info(`User ${ctx.user.id} referred by ${referrer.id}`);
        }
      }

      // Give registration bonus
      await rewardService.awardReward(
        ctx.user.id,
        'REGISTRATION',
        100  // 100 KIK registration bonus
      );

      // Give referral signup bonus to referrer
      if (referralCode) {
        const referrer = await db.getUserByReferralCode(referralCode);
        if (referrer) {
          await rewardService.awardReward(
            referrer.id,
            'REFERRAL_SIGNUP',
            1000  // 1000 KIK referral bonus
          );
        }
      }
    } else {
      // Daily login bonus
      const today = new Date().toISOString().split('T')[0];
      const lastLogin = ctx.user.lastLoginDate;

      if (lastLogin !== today) {
        await rewardService.claimReward(
          ctx.user.id,
          'DAILY_LOGIN',
          'Daily login bonus'
        );
        await db.updateUserLastLogin(ctx.user.id, today);
      }
    }

    // Welcome message
    const welcomeMsg = isNewUser
      ? `üéâ Welcome to KIK Collectibles!\n\nYou've received 100 KIK tokens as registration bonus!\n\nüé® Create unique AI-generated collectibles\nüíé Trade them with other users\nüéÅ Gift them to friends\nüë• Invite friends and earn rewards\n\nGet started by creating your first collectible!`
      : `üëã Welcome back!\n\nYou've received 10 KIK tokens for daily login!\n\nBalance: ${ctx.user.balance} KIK`;

    await ctx.reply(welcomeMsg, Markup.keyboard([
      ['üé® Create NFT', 'üíº My Collection'],
      ['üõí Marketplace', 'üë• Invite Friends'],
      ['üí∞ Rewards', 'üì∫ Watch Ad'],
      ['‚öôÔ∏è Settings']
    ]).resize());

  } catch (error) {
    logger.error('Start command error:', error);
    await ctx.reply('‚ùå Something went wrong. Please try again.');
  }
});

// /create - Create AI-generated NFT
bot.command('create', async (ctx) => {
  const prompt = ctx.message.text.replace('/create', '').trim();

  if (!prompt) {
    return ctx.reply(
      'üé® Create a collectible!\n\nUsage: /create <description>\n\nExample:\n/create red ferrari car\n/create cute cat with blue eyes\n/create futuristic city at sunset\n\nCost: 100 KIK\nYou\'ll receive 50 KIK bonus after creation!'
    );
  }

  try {
    // Check daily limit
    const canCreate = await nftService.checkDailyLimit(ctx.user.id);
    if (!canCreate && !ctx.user.isPremium) {
      return ctx.reply(
        '‚è≥ Daily limit reached (5 collectibles/day)\n\nüíé Upgrade to Premium for unlimited creation!\n\nUse /premium to learn more.'
      );
    }

    // Check balance
    if (ctx.user.balance < 100) {
      return ctx.reply(
        `‚ùå Insufficient balance!\n\nYou need 100 KIK to create a collectible.\nYour balance: ${ctx.user.balance} KIK\n\nEarn more KIK:\n‚Ä¢ Watch ads (/watchad)\n‚Ä¢ Invite friends (/invite)\n‚Ä¢ Daily login bonus`
      );
    }

    await ctx.reply('üé® Creating your collectible...\n‚è≥ This may take 10-30 seconds...');

    // Generate NFT
    const nft = await nftService.createNFT(ctx.user.id, prompt);

    // Send NFT image
    await ctx.replyWithPhoto(nft.imageUrl, {
      caption: `‚ú® Your collectible is ready!\n\nüé® Name: ${nft.name}\nüíé Rarity: ${nft.rarity}\nüÜî Token ID: ${nft.tokenId}\n\nüéÅ You received 50 KIK creation bonus!\n\nYou can:\n‚Ä¢ List it on marketplace (/marketplace)\n‚Ä¢ Gift it to a friend (/gift)\n‚Ä¢ Keep it in your collection!`,
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üõí List for Sale', callback_data: `list_nft:${nft.tokenId}` },
            { text: 'üéÅ Gift', callback_data: `gift_nft:${nft.tokenId}` }
          ]
        ]
      }
    });

  } catch (error) {
    logger.error('Create NFT error:', error);
    await ctx.reply('‚ùå Failed to create collectible. Please try again.');
  }
});

// /gift - Gift NFT to another user
bot.command('gift', async (ctx) => {
  const args = ctx.message.text.split(' ');

  if (args.length < 3) {
    return ctx.reply(
      'üéÅ Gift a collectible!\n\nUsage: /gift @username <nft_id>\n\nExample:\n/gift @friend 123\n\nBoth you and your friend will receive 50 KIK!'
    );
  }

  try {
    const recipientUsername = args[1].replace('@', '');
    const nftId = parseInt(args[2]);

    const recipient = await db.getUserByUsername(recipientUsername);
    if (!recipient) {
      return ctx.reply('‚ùå User not found. Make sure they have started the bot!');
    }

    if (recipient.id === ctx.user.id) {
      return ctx.reply('‚ùå You cannot gift to yourself!');
    }

    // Transfer NFT
    await nftService.giftNFT(ctx.user.id, recipient.id, nftId);

    // Give rewards to both
    await rewardService.claimReward(ctx.user.id, 'GIFT_SENT', `Gifted NFT ${nftId}`);
    await rewardService.claimReward(recipient.id, 'GIFT_RECEIVED', `Received NFT ${nftId}`);

    await ctx.reply(`‚úÖ NFT #${nftId} gifted to @${recipientUsername}!\n\nüéÅ You received 50 KIK for sending a gift!`);

    // Notify recipient
    await bot.telegram.sendMessage(
      recipient.telegramId,
      `üéÅ You received a gift from @${ctx.from.username}!\n\nNFT #${nftId} is now in your collection!\nüí∞ You also received 50 KIK bonus!`
    );

  } catch (error) {
    logger.error('Gift NFT error:', error);
    await ctx.reply('‚ùå Failed to gift NFT. Please try again.');
  }
});

// /marketplace - Browse marketplace
bot.command('marketplace', async (ctx) => {
  try {
    const listings = await db.getActiveListings(20);

    if (listings.length === 0) {
      return ctx.reply('üõí Marketplace is empty!\n\nBe the first to list a collectible for sale!');
    }

    let message = 'üõí **Marketplace**\n\nLatest listings:\n\n';

    listings.forEach((listing, i) => {
      message += `${i + 1}. ${listing.name} (${listing.rarity})\n`;
      message += `   üí∞ Price: ${listing.price} KIK\n`;
      message += `   üë§ Seller: @${listing.sellerUsername}\n`;
      message += `   /buy_${listing.id}\n\n`;
    });

    await ctx.reply(message, { parse_mode: 'Markdown' });

  } catch (error) {
    logger.error('Marketplace error:', error);
    await ctx.reply('‚ùå Failed to load marketplace.');
  }
});

// /invite - Get referral link
bot.command('invite', async (ctx) => {
  try {
    const referralCode = ctx.user.referralCode || await db.createReferralCode(ctx.user.id);
    const referralLink = `https://t.me/${process.env.BOT_USERNAME}?start=${referralCode}`;

    const stats = await referralService.getReferralStats(ctx.user.id);

    await ctx.reply(
      `üë• **Invite Friends & Earn!**\n\n` +
      `Your referral link:\n${referralLink}\n\n` +
      `üìä Your Stats:\n` +
      `‚Ä¢ Direct referrals: ${stats.directReferrals}\n` +
      `‚Ä¢ Pending rewards: ${stats.pendingRewards} KIK\n` +
      `‚Ä¢ Total earned: ${stats.claimedRewards} KIK\n\n` +
      `üí∞ Earn 1000 KIK for each friend who joins!\n` +
      `üíé Plus 15% of all their rewards forever!\n\n` +
      `Share your link now!`,
      {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üì§ Share Link', url: `https://t.me/share/url?url=${encodeURIComponent(referralLink)}&text=${encodeURIComponent('Join KIK Collectibles and earn crypto!')}` }]
          ]
        }
      }
    );

  } catch (error) {
    logger.error('Invite command error:', error);
    await ctx.reply('‚ùå Failed to generate invite link.');
  }
});

// /watchad - Watch rewarded video ad
bot.command('watchad', async (ctx) => {
  try {
    // Check if user watched ad recently
    const cooldownKey = `ad_cooldown:${ctx.user.id}`;
    const cooldown = await redis.get(cooldownKey);

    if (cooldown) {
      const remaining = Math.ceil((parseInt(cooldown) - Date.now()) / 60000);
      return ctx.reply(`‚è≥ You can watch another ad in ${remaining} minutes.`);
    }

    // Get reward ad
    const adData = await adManager.getRewardAd();

    if (!adData) {
      return ctx.reply('üòî No ads available right now. Try again later!');
    }

    await ctx.replyWithVideo(adData.videoUrl, {
      caption: `üì∫ Watch this ${process.env.REWARD_AD_DURATION}s ad to earn ${process.env.REWARD_AD_REWARD} KIK!\n\n${adData.title}`,
      reply_markup: {
        inline_keyboard: [
          [{ text: '‚úÖ I Watched the Ad', callback_data: `claim_ad_reward:${adData.id}` }]
        ]
      }
    });

  } catch (error) {
    logger.error('Watch ad error:', error);
    await ctx.reply('‚ùå Failed to load ad.');
  }
});

// /rewards - Check pending rewards
bot.command('rewards', async (ctx) => {
  try {
    const stats = await referralService.getReferralStats(ctx.user.id);

    await ctx.reply(
      `üí∞ **Your Rewards**\n\n` +
      `üíé Pending: ${stats.pendingRewards} KIK\n` +
      `‚úÖ Claimed: ${stats.claimedRewards} KIK\n\n` +
      `Minimum claim: 10 KIK\n\n` +
      stats.pendingRewards >= 10
        ? `Use /claim to claim your rewards!`
        : `Earn more by inviting friends!`,
      { parse_mode: 'Markdown' }
    );

  } catch (error) {
    logger.error('Rewards command error:', error);
    await ctx.reply('‚ùå Failed to load rewards.');
  }
});

// /claim - Claim referral rewards
bot.command('claim', async (ctx) => {
  try {
    const result = await referralService.claimRewards(ctx.user.id);

    if (result.success) {
      await ctx.reply(`‚úÖ Claimed ${result.amount} KIK!\n\nNew balance: ${result.newBalance} KIK`);
    } else {
      await ctx.reply(`‚ùå ${result.error}`);
    }

  } catch (error) {
    logger.error('Claim command error:', error);
    await ctx.reply('‚ùå Failed to claim rewards.');
  }
});

// /premium - Show premium subscription info
bot.command('premium', async (ctx) => {
  try {
    await ctx.reply(
      `üíé **KIK Premium**\n\n` +
      `Benefits:\n` +
      `‚ú® Ad-free experience\n` +
      `üé® Unlimited NFT creation\n` +
      `‚ö° Priority support\n` +
      `üéÅ Exclusive templates\n` +
      `üí∞ +20% reward bonus\n\n` +
      `Price: $${process.env.PREMIUM_PRICE_USD}/month\n\n` +
      `Subscribe now and enjoy all benefits!`,
      {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üíé Subscribe Now', callback_data: 'subscribe_premium' }]
          ]
        }
      }
    );

  } catch (error) {
    logger.error('Premium command error:', error);
    await ctx.reply('‚ùå Failed to load premium info.');
  }
});

// ============================================
// CALLBACK HANDLERS
// ============================================

// Close ad callback
bot.action('close_ad', async (ctx) => {
  try {
    await ctx.deleteMessage();
    await ctx.answerCbQuery('Ad closed');
  } catch (error) {
    logger.error('Close ad error:', error);
  }
});

// Claim ad reward callback
bot.action(/claim_ad_reward:(.+)/, async (ctx) => {
  const adId = ctx.match[1];

  try {
    // Verify ad was watched (check impression timestamp)
    const impression = await adManager.getImpression(adId, ctx.from.id);

    if (!impression) {
      return ctx.answerCbQuery('‚ùå Ad not found', { show_alert: true });
    }

    // Check if enough time passed (ad duration)
    const elapsed = Date.now() - impression.timestamp;
    const requiredDuration = parseInt(process.env.REWARD_AD_DURATION) * 1000;

    if (elapsed < requiredDuration) {
      return ctx.answerCbQuery('‚è≥ Please watch the full ad', { show_alert: true });
    }

    // Give reward
    await rewardService.giveAdReward(ctx.user.id, parseInt(process.env.REWARD_AD_REWARD));

    // Set cooldown (5 minutes)
    const cooldownKey = `ad_cooldown:${ctx.user.id}`;
    await redis.setex(cooldownKey, 300, Date.now() + 300000);

    await ctx.answerCbQuery(`‚úÖ You earned ${process.env.REWARD_AD_REWARD} KIK!`, { show_alert: true });
    await ctx.editMessageCaption(`‚úÖ Reward claimed! You earned ${process.env.REWARD_AD_REWARD} KIK!`);

  } catch (error) {
    logger.error('Claim ad reward error:', error);
    await ctx.answerCbQuery('‚ùå Failed to claim reward');
  }
});

// ============================================
// ERROR HANDLING
// ============================================

bot.catch((err, ctx) => {
  logger.error('Bot error:', err);
  ctx.reply('‚ùå An error occurred. Please try again later.');
});

// ============================================
// START BOT
// ============================================

async function start() {
  try {
    // Database and Redis are already initialized (in-memory or real)
    logger.info('Database ready (in-memory mode)');
    logger.info('Redis ready (in-memory mode)');

    // Start Express server
    app.listen(process.env.PORT || 3000, () => {
      logger.info(`Server running on port ${process.env.PORT || 3000}`);
    });

    // Start bot
    await bot.launch();
    logger.info('‚úÖ Bot started successfully!');
    logger.info(`Bot username: @${bot.botInfo.username}`);
    logger.info('Ready to receive updates...');

  } catch (error) {
    logger.error('Failed to start bot:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.once('SIGINT', () => {
  bot.stop('SIGINT');
  process.exit(0);
});
process.once('SIGTERM', () => {
  bot.stop('SIGTERM');
  process.exit(0);
});

// Start the bot
start();
